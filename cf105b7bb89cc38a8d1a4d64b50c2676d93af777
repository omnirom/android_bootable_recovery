{
  "comments": [
    {
      "key": {
        "uuid": "6b22818b_c998b5c5",
        "filename": "gui/pages.cpp",
        "patchSetId": 1
      },
      "lineNbr": 943,
      "author": {
        "id": 1000768
      },
      "writtenOn": "2015-04-10T20:43:39Z",
      "side": 1,
      "message": "While this will most likely work in practice, the standard says that erase invalidates the iterator and returns the next position. But since we don\u0027t allow duplicates anyway, we could simply break after erasing.\n\nGenerally, using erase in a vector is perfectly fine as long as the vector contains few elements and you don\u0027t do it in a performance-critical inner loop.",
      "revId": "cf105b7bb89cc38a8d1a4d64b50c2676d93af777",
      "serverId": "56841c99-7c94-43d4-bf0b-cb4707e66d55",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6b22818b_0993ada7",
        "filename": "gui/pages.cpp",
        "patchSetId": 1
      },
      "lineNbr": 943,
      "author": {
        "id": 1000817
      },
      "writtenOn": "2015-04-10T20:51:23Z",
      "side": 1,
      "message": "I actually tried code which I thought would satisfy the standard you mention:\n\niter \u003d mOverlays.erase(iter);\n\nBut apparently, I\u0027m misinterpreting the return (or order of operations), because this led to \"error to allocate [lots of memory] for new\". It think your suggestion for simply breaking after erase is appropriate since duplicates aren\u0027t allowed.",
      "parentUuid": "6b22818b_c998b5c5",
      "revId": "cf105b7bb89cc38a8d1a4d64b50c2676d93af777",
      "serverId": "56841c99-7c94-43d4-bf0b-cb4707e66d55",
      "unresolved": false
    }
  ]
}